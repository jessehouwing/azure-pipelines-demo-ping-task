import Q = require('q');
import events = require('events');
import stream = require('stream');
/**
 * Interface for exec options
 *
 * @param     cwd        optional working directory.  defaults to current
 * @param     env        optional envvar dictionary.  defaults to current processes env
 * @param     silent     optional.  defaults to false
 * @param     failOnStdErr     optional.  whether to fail if output to stderr.  defaults to false
 * @param     ignoreReturnCode     optional.  defaults to failing on non zero.  ignore will not fail leaving it up to the caller
 */
export interface IExecOptions {
    cwd: string;
    env: {
        [key: string]: string;
    };
    silent: boolean;
    failOnStdErr: boolean;
    ignoreReturnCode: boolean;
    outStream: stream.Writable;
    errStream: stream.Writable;
}
/**
 * Interface for exec results returned from synchronous exec functions
 *
 * @param     stdout      standard output
 * @param     stderr      error output
 * @param     code        return code
 * @param     error       Error on failure
 */
export interface IExecResult {
    stdout: string;
    stderr: string;
    code: number;
    error: Error;
}
export declare class ToolRunner extends events.EventEmitter {
    constructor(toolPath: any);
    toolPath: string;
    args: string[];
    silent: boolean;
    private pipeOutputToTool;
    private _debug(message);
    private _argStringToArray(argString);
    /**
     * Add argument
     * Append an argument or an array of arguments
     * returns ToolRunner for chaining
     *
     * @param     val        string cmdline or array of strings
     * @returns   ToolRunner
     */
    arg(val: string | string[]): ToolRunner;
    /**
     * Append argument command line string
     * e.g. '"arg one" two -z' would append args[]=['arg one', 'two', '-z']
     * returns ToolRunner for chaining
     *
     * @param     val        string cmdline
     * @returns   ToolRunner
     */
    line(val: string): ToolRunner;
    /**
     * Add argument(s) if a condition is met
     * Wraps arg().  See arg for details
     * returns ToolRunner for chaining
     *
     * @param     condition     boolean condition
     * @param     val     string cmdline or array of strings
     * @returns   ToolRunner
     */
    argIf(condition: any, val: any): this;
    /**
     * Pipe output of exec() to another tool
     * @param tool
     * @returns {ToolRunner}
     */
    pipeExecOutputToTool(tool: ToolRunner): ToolRunner;
    /**
     * Exec a tool.
     * Output will be streamed to the live console.
     * Returns promise with return code
     *
     * @param     tool     path to tool to exec
     * @param     options  optional exec options.  See IExecOptions
     * @returns   number
     */
    exec(options?: IExecOptions): Q.Promise<number>;
    /**
     * Exec a tool synchronously.
     * Output will be *not* be streamed to the live console.  It will be returned after execution is complete.
     * Appropriate for short running tools
     * Returns IExecResult with output and return code
     *
     * @param     tool     path to tool to exec
     * @param     options  optionalexec options.  See IExecOptions
     * @returns   IExecResult
     */
    execSync(options?: IExecOptions): IExecResult;
}
